# Algorithms and Data Structures

## Important notes and links

---
---

## 3.1 Что такое HashMap и зачем он нужен

* **Python**: `dict`
* **Java**: `HashMap`
* **C++**: `std::unordered_map`
* **JavaScript**: `Object` or `Map`
* **PHP**: `array` (associative arrays)

Коллизий в хеш функциях невозможно избежать.

## 3.3 Базовая реализация HashMap

Примерный принцип работы динамического массива:

* Если массив заполнен - увеличить его размер вдвое
* Если массив заполнен менее чем на четверть - уменьшить его размер вдвое

HashMap также использует эти принципы. При изменении размера массива, также
пересчитываются индексы добавленных значений.

## 3.4 Разрешение коллизий: Открытая Адресация

Один из способов разрешения коллизии поставить новую запись на следующий индекс
внутреннего массива или далее если и он занят.

## 4.1 Оценка асимптотической сложности алгоритмов

Если алгоритм работает всегда за одно и тоже время, говорят, что время работы
алгоритма константа.

**Скорость работы алгоритма по O(n):**

* Константное время - O(1)
* Линейное время - O(n)
* Квадратичное время - O(n^2)

## 4.2 Динамические массивы

При фиксированном увеличении внутреннего массива который находится в  динамическом
массиве, сложность добавления будет O(n^2). При удваивании размера, сложность будет
O(n).

## 4.3 Односвязные списки

Список позволяет добавлять элементы в конец и начало, со сложностью O(1).

Для нахождения N-ого элемента с конца, можно использовать метод "Два указателя".

Ссылку в списке можно иметь не только на первый, но и на последний и на средний
и на какой то другой элемент списка.

## 5.3 Очередь

Очередь можно реализовать с помощью циклического массива и указателей.
При создании очереди на основе массива, можно быстро получать значение любого
элемента очереди. Также внутренние механизмы позволяют использовать кэш для
массива, что также ведет к ускоренной работе с ним.

## 5.4 Альтернативные методы реализации очереди

Очередь можно реализовать с помощью:

* Списка
* Зацикленного массива
* 2 стеков

Очередь из стеков можно сделать перенося элементы из одного стека в другой, если
второй стек пустой.

## 5.5 Дек

На английском пишется как `Deque` или `Dequeue` (Устаревшее).

Задачи требующие использование дека, встречаются не очень часто.

Дек можно реализовать с помощью:

* Списка
* Зацикленного массива
* Двух стеков
